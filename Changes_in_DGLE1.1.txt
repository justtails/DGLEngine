
##########################################
##Изменения и добавления в DGLEngine.dll##
##########################################


DGLE 1.1 RC2 ChangeLog 30.04.2008

*Поправлен косяк, что ShadowMap Textures не рендерились через FBO

*Можно делать бампмапинг для сцены

*Добавлена возможность принудительного отключения FBO (UseFBO : procedure (Enable : boolean); stdcall;)

*Добавлена возможность проецировать текстуру с использованием врешинного шейдера (процедура GiveVShaderTexProjectMatrix) (пока в тестовом режиме)

*Устранил утечку памяти в модуле звука приводящую к AV при выходе иногда

*Поддержка O3TC формата текстур. Файлы текстур создаются специальной утилитой "DXTViewer", которую можно скачать с моего сайта. Файл этого формата уже содержит текстуру с созданными мипуровнями и пожатую S3TC стандартом, что делает загрузку текстуры моментальной и минимальный расходуемый на нее объем памяти.

*Мелкие багфиксы
DGLE 1.1 RC1 ChangeLog 13.04.2008



*Корректная работа на двухядерных процессорах (Теперь процесс движка не перекидывается планировщиком то на одно ядро то на другое из-за чего возникало дерганье)

*Ускорена работа в оконном режиме (Раньше при работе в окне после вызова рендера стоял Sleep(1) дабы не загружать процессор на 100%, что понижало на 30-40% FPS в оконном режиме)

*Поддержка моделей формата DMD 2.0 (новый экспортер моделей из макса прилогается)

*Загрузка файлов сцен из DSC 1.0 файлов который создает новый экспортер MExport.ms при экспорте всей сцены

*Расчет столкновения BoundingBox со сценой

*Использование VBO для геометрии (будет уиспользоваться всегда если есть аппаратная возможность). Увеличило скорость в ~5 раз в примере Frustum Culling (поставляется с движком) с 40 FPS подскочили до 195 :)

*Изменена работа ф-и FreeDGLEngineDLL, теперь если при выходе из программы возникают ошибки, то можно корректно закрыть процесс передав в качестве параметра TRUE

*Поддержка работы с простыми шейдерами pixel и vertex (Fragment и Vertex programs) используются PixelShaders 2.0

*Для оконного режима заблокирована кнопка maximize window, дабы не порождать разного рода баги при изменении размеров окна

*По просьбам реализованы ф-и Get3DPosFree и GetWindowHandle

*Предусмотрен случай при загрузке текстур, когда видеокарта не поддерживает такое разрешение текстур          

*Если использовать Color3D с параметром диффуз true, а потом в 2Д рисовать примитивы, то альфа функция была не верна

*Раньше проецирование текстуры не учитывал задаваемую пользователем процедурой SetCutingPlanes ближнюю и дальнюю плоскости отсечения

*Возможность устанавливать отсечение полигонов FRONT или BACK

*Возможность обращения к треугольникам модели, для расчета точных столкновений например

*Расчет тангент для меша и как следствие внедрение bump+specular маппинга для моделей

*Быстрый рендеринг экрана в текстуру через FrameBuffer, используется всегда, если есть аппаратная возможность. Для моментального рендеринга текстуры в текстуры через FBO появилась функция RenderTexToTexFBO (см. новый пример "Render tex to tex via FBO")

####################
##Изменения утилит##
####################

*Переделан скрипт экспорта моделей MExport.ms, теперь он позволяет экспортировать целиком уровни из макса а в сами модели дописывается информация о материале. Да и вообще, пользоваться скриптом стало удобнее, например он научился центровать и масштабировать модели. Сопутствующая документация скрипта тоже обновлена.
Формат DMD 2.0 обратно совместим с DMD 1.0 и 1.1

#################
##Новые примеры##
#################

*Scenes_Advanced
Демонстрирует загрузку целиком уровня из макса с текстурами и материалами, расчет столкновений со сценой, динамические стенсильные тени, FPS перемещение, skybox

*Scenes_Simple
Загрузка сцены из макса с материалами, расчет динамических теней с самозатенением по технологии ShadowMapping с размытием в пиксельном шейдере.

*Shaders
Пример показывает работу с пиксельными и вертексными шейдерами для достижения эффектов в 2D и 3D

*BumpMapping
Пример Normal+Specular bump mapping'а для произвольного DMD меша. Все расчеты производятся в vertex и pixel шейдере, падение FPS по сравнению с обычным текстурированием практически нет.

*Render tex to tex via FBO
Пример демонстрирует моментальный рендеринг текстуры в текстуру падение FPS вообще не наблюдается.

###############################
##Новые функции и их описание##
###############################

==================================================================================================
TMaterial = record
 diffuse : array [0..2] of byte; //RGB цвет
 glossiness : single;
 alpha : byte;
 TexFileName, NormalMapFileName, SpecularMapFileName : string[128];
end;
ModelMaterial : function (Modelident : integer) : TMaterial; stdcall;
---------------------------------------------------------------------------------------------------
Функция возвращает информацию о материале и именах текстур записываемые в файл модели DMD 2.0
===================================================================================================
TTangent = record
bitangent : TVertex;
tangent   : TVertex4D;
end;
TMeshGeometry = record
VerticesCount, FacesCount : cardinal;
Vertices, Normals : array of TVertex;
Tangents : array of TTangent;
Faces : array of array[0..2] of cardinal;
TextureVertices : array of TVertex;
TextureFaces : array of array[0..2] of cardinal;
end;
PMeshGeometry = ^TMeshGeometry;
GetModelGeometry : procedure (ModelIdent, Frame : integer; GeometryData : PMeshGeometry); stdcall;
---------------------------------------------------------------------------------------------------
Функция возвращает информацию о геометрии модели (треугольники, текстурные координаты, расчитанные тангенты, нормали и т.д.). Эту информацию можно использовать для расчета математических столкновений, что бы рисовать кровь на текстуре модели в месте попадания пули например, ну или можете удалить модель, а вывод делать своими средствами по полученной геометрической информации.
Вот псевдокод для того что бы построить треугольник:
for int i =0 to FacesCount-1
{
	Tvertex v1 = Vertices[Faces[i][0]];
	Tvertex v2 = Vertices[Faces[i][1]];
	Tvertex v3 = Vertices[Faces[i][2]];
} 
Так получаем треугольник, аналогично извлекаются и текстурные координаты для него.
===================================================================================================
ModelsBump : procedure (Active : boolean); stdcall;
---------------------------------------------------------------------------------------------------
Включает/Отключает отрисовку моделей с бампмапингом. Влияет на все отрисовываемые после вызова модели. См. пример бампмапинга.
===================================================================================================
UseFBO : procedure (Enable : boolean); stdcall;
---------------------------------------------------------------------------------------------------
Принудительно можно выключить рендер в текстуру через FBO, даже если он аппаратно поддерживается.
===================================================================================================
UseVBO : procedure (Enable : boolean); stdcall;
---------------------------------------------------------------------------------------------------
По умолчанию если есть аппаратная возможность все модели загружаются с использованием VertexBufferObject(VBO), но можно пренудительно не использовать VBO, вызвав ф-ю с параметром false. Эта ф-я влияет на все загружаемые после ее вызова модели.
===================================================================================================
IsVBOSupported : function : boolean; stdcall;
IsFBOSupported : function : boolean; stdcall;
---------------------------------------------------------------------------------------------------
Поддерживаются или нет соответствующие техники.
===================================================================================================
GetWindowHandle : function : HWND; stdcall;
---------------------------------------------------------------------------------------------------
Ф-я возвращает хэндл окна движка, если движок создает свое окно а не рендерит в панель, во втором случае значение ф-и - не определено.
===================================================================================================
LoadScene : function (FileName, MeshPath, TexPath : string):cardinal; stdcall;
---------------------------------------------------------------------------------------------------
Ф-я загружает модель из *.dsc файла.
MeshPath - директория или имя DPC архива в котором будет вестись поиск моделей сцены.
TexPath - директория или имя DPC архива в котором будет вестись поиск текстур для моделей сцены.
Ф-я возвращает идентификатор загруженной сцены.
===================================================================================================
FreeScene : procedure (Ident : cardinal); stdcall;
---------------------------------------------------------------------------------------------------
Удаляет сцену и все связанные с ней текстуры и модели.
===================================================================================================
DrawScene : procedure (Ident : cardinal); stdcall;
---------------------------------------------------------------------------------------------------
Рисует сцену. Нужно учесть, что если перед вызовом ф-и был произведен расчет фрустума, то объекты в сцене будут автоматически отсекаться по расчитанному фрустуму.
===================================================================================================
SceneBoundingBox : function (Ident : cardinal):TVertex; stdcall;
---------------------------------------------------------------------------------------------------
Возвращает ширину, высоту и глубину коробки описанной вокруг сцены.
===================================================================================================
CollideBoxWithScene : function (Ident : cardinal; BoxPos, BoxSize : Tvertex):boolean; stdcall;
---------------------------------------------------------------------------------------------------
Проверяет столкновение коробки со сценой в системе координат сцены. (См. примеры)
===================================================================================================
SceneGetLastCollideObjectIndex : function :integer; stdcall;
---------------------------------------------------------------------------------------------------
Возвращает индекс объекта в сцене с которым произошло последнее столкновение, расчитанное ф-ей CollideBoxWithScene, иначе возвращается -1.
===================================================================================================
SceneUseMaterial : procedure (Enable : boolean); stdcall;
---------------------------------------------------------------------------------------------------
Вызывается до отрисовки сцены и говорит движку что бы он игнорировал материалы для сцены т.е. рендерится голая геометрия.
===================================================================================================
SceneObjCount : function ( Ident : cardinal ) : cardinal; stdcall;
---------------------------------------------------------------------------------------------------
Возвращает колличество объектов в сцене.
===================================================================================================
GetSceneObjectIdent : function ( SceneIdent : cardinal; ObjName : string ) : integer; stdcall;
---------------------------------------------------------------------------------------------------
Возвращает индекс модели в сцене по имени. Имя - задается в 3DStudioMax (напр. Box01, Plane11 и т.д.). Если модели не нашлось возвращается -1.
===================================================================================================
SceneSetObjActive : procedure ( SceneIdent, ObjIdent : cardinal; Active : boolean ); stdcall;
---------------------------------------------------------------------------------------------------
Устанавливает видимость для конкретной модели в сцене. Скрытые объекты не отрисовываются и столкновения с ними не расчитываются.
===================================================================================================
SceneSetObj : procedure ( SceneIdent, ObjIdent : cardinal; SceneMesh : TSceneMesh ); stdcall;
SceneGetObj : function ( SceneIdent, ObjIdent : cardinal ) : TSceneMesh; stdcall;

TSceneMesh = record
Active      : boolean; //активен объект или нет
Name        : string[128]; //символьное имя объекта из макса
Pos         : Tvertex; //Позиция объекта в сцене
Scale       : single;	//Масштаб в сцене
Material    : TMaterial;//Материал модели аналогичный тому что возвращает меш
Texture     : cardinal;//Идентификатор текстуры модели записанной в менеджере текстур движка
DoBump      : boolean;//Будет модель бампмапится или нет
BumpTexture : cardinal;//Текстура normal
SpecTexture : cardinal;//Текстура specular
MeshFrame   : cardinal;//Номер кадра анимации модели
MeshSmooth  : boolean; //сглаживать или нет модель
Mesh        : cardinal;//Идентификатор на меш, меш записывается в менеджере мешей двига и пригоден к использованию любым способом :)
end;
---------------------------------------------------------------------------------------------------
Эти две ф-и возвращают и устанавливают конкретной модели сцене свойства.
===================================================================================================
LoadShader : function (target: Cardinal; shader: string): Cardinal; stdcall;
FreeShader : procedure (Ident : cardinal); stdcall;
SetShader : procedure (Ident : integer); stdcall;
GiveShaderParams : procedure (Ident, Index : cardinal; v : TVertex; w : single); stdcall;
---------------------------------------------------------------------------------------------------
Функции для работы с шейдерами, смотри примеры к движку.
===================================================================================================
 CULL_NONE  = $000000;
 CULL_FRONT = $000001;
 CULL_BACK  = $000002;

CullFace : procedure (Mode : cardinal) ; stdcall;
---------------------------------------------------------------------------------------------------
Устанавливает отсечение полигонов, передних, задних или отключает вовсе отсечения.
===================================================================================================
RenderTexToTexFBO : procedure (ToTexture,TexSource,TexTarget : Cardinal; X,Y : integer); stdcall;
---------------------------------------------------------------------------------------------------
Рендерит текстуру в текстуру с использованием FBO. Работает моментально.
ToTexture - текстура результат рендера, размер должен быть равен размеру текстуры TexTarget
TexTarget - текстура в которую рендерим
TexSource - текстуру которая будет врисована в TexTarget с учетом прозрачности TexSource
Смотри пример к движку :)
===================================================================================================

###########
## TO DO ##
###########

*Плагин PostRenderEffects
*Плагин настройки параметров движка
*Плагин DirectInput
*Расчет точных столкновений по треугольникам
*Пример шейдерной водички
*Управление антиалиасингом
*Совмещение normal mapping'а и теней

################
## KNOWN BUGS ##
################

GiveVShaderTexProjectMatrix работает не верно, будет исправлено к следующему релизу.