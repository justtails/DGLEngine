<HTML>
<HEAD>
    <TITLE>DRON_PROGS</TITLE> 
<META content="text/html; charset=WINDOWS-1251" http-equiv=Content-Type>                     
<META name="author" content="DRON">
<META name="keywords" content="программирование, программирование игр, gamedev, Delphi, Java, J2ME, C#, C++, mono, tao, фото, engine, 3d, полезные программы, звук, графика, коды, DirectX, OpenGL, библиотеки, компоненты, как создать игру, движок, движок на Delphi, DRON, Коротков Андрей, скачать, примеры, исходники, source, OpenGL Engine, 3D, анимированные модели, max, Power Draw, Asphyre, DelphiX, обучение, dglengine, бесплатно, ролевая игра, RPG, стрелялка, shooter, games, статьи, помощь"> 
<META name="description" content="Обитель DRON'а. Программирование на Delphi, C#, C++ и J2ME. Gamedev: 2D/3D, статьи, исходники, примеры, движки."> 
<style type="text/css">
#menu_body{background:#808080;width:140px}
#menu_body ul li{list-style-type:none;border-bottom:1px solid #fff;margin-left:-40px;padding-left:7px}
#menu_body ul li a{color:#fff;font-family:verdana,arial,sans-serif;text-decoration:none}
#menu_body ul li ul li{border:0;list-style-type:square;color:#fff;list-style-position:inside}
#menu_body ul li ul{border-top:1px solid #fff;margin-left:-7px;padding-left:50px}
#menu_body li ul{display:none}
#menu_body li:hover ul, #menu_body li.over ul{display: block}

body,td,th {
	font-family:  tahoma, Arial, Helvetica;
	font-size: 11px;
	color: Black;
	text-decoration:none;
}
body {
	background-color: White;
	margin-left: 0px;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 0px;
	text-decoration:none;
}
a:link {
	color: Black;
	text-decoration:none;
}
a:visited {
	color: Black;
	text-decoration:none;
}
a:hover {
	color: Gray;
	text-decoration:underline;
}
a:active {
	color: Gray;
	text-decoration:none;
}
</style>

<script type="text/javascript">
startList = function() {
      if (document.all&&document.getElementById) {
            navRoot = document.getElementById("ul1");
            for (i=0; i<navRoot.childNodes.length; i++) {
                  node = navRoot.childNodes[i];
                  if (node.nodeName=="LI") {
                        node.onmouseover=function() {
                              this.className+=" over";
                        }
                        node.onmouseout=function() {
                              this.className=this.className.replace(" over", "");
                        }
                  }
            }
      }
}
window.onload=startList;
</script>
</HEAD>        
<BODY BottomMargin=0 text=Black color=#ffffff style="background:url('images/up.jpg') top center no-repeat;" topmargin="0" leftmargin="0">
<table cellspacing="0" align=center cellpadding="0" width=90% border=0 height=100% >
<tr><td height=100% background="images/cornerl.gif">&nbsp;</td>
<td><table border=0 style="background:url('images/dronslogo.gif') top right no-repeat;" cellspacing="0" cellpadding="0">
<tr><td valign=top>
<table width=100% border=0 cellspacing="0" cellpadding="3"><br>
<center><img src="images/dron_small.gif" width=100 height=98 border=0></center>
<br>
<? include("menu.txt");?>
</table></td>
<td>
<table border=0 style="background:url('images/line.gif') top left no-repeat;" cellspacing="4" cellpadding="4">
<tr>
<td style="padding-top:20px" height=100% valign=top>

<br><br>
<b><a href="index.htm"><u>Уроки по DGLEngine</u></a> &#151;> "Твоя первая настоящая 3D игра :)"</b><br><br>

<p>
Добро пожаловать в очередной урок по работе с DGLE! Сегодня мы будем делать не что иное, как полноценный шутер от первого лица, причем с вполне современной графикой, бампмапингом и динамическими тенями(их оставим для следующей статьи дабы не раздувать эту).
<br>
 Предыдущий урок продемонстрировал самые базовые основы работы с 3D графикой в DGLE. Теперь мы продвинемся на порядок дальше. В версии 1.1 стало намного проще работать со сложной 3D графикой благодаря использованию сцен. По этому первое что надо сделать это - рассказать что такое сцены. На самом деле сцена это грубо говоря массив моделей, где для каждой модели хранятся ее координаты в пространстве, материал (цвет, текстура и т.д.) и собственно сама модель. Сцена экспортируется целиком из макса при помоще обновленного в DGLE 1.1 скрипта экспорта моделей (MExport.ms). При экспорте сцены создается файл с расширением .dsc в который записывается информация об объектах и множество dmd моделей, на каждый объект по одной моделе. Далее достаточно просто вызвать ф-ю LoadScene, указать ей имя DSC файла и папок в которых будет происходить поиск текстур и моделей для сцены. В качестве путей папок, кстати, могут выступать DPC паки, что очень удобно. Ф-я загрузки сцены возвращает идентификатор по которому и можно в дальнейшем работать с этой сценой. Например нарисовать сцену можно за один вызов DrawScene, передав ему идентификатор сцены.
<br>
Ну вот, хватит теории, теперь перейдем к практике. Сразу хочу сказать, что я не хочу раздувать ни текст этой статьи ни исходный код примера, по этому в нашем шутере придется отказаться от выстрелов, гравитации и на карте будет присутствовать только один враг. Я думаю что читателю не составит большого труда доработать этот пример по своему усмотрению.
<br>
Ну вот приступим собственно к кодингу. Для опытов я возьму пример из предыдущего урока. Вынесу код отрисовки пистолета в отдельную процедуру, что бы не мешался и начну пожалуй с того что нарисую небо. Для этого буду использовать обычный skybox. Я заранее смоделил его в максе, в принципе коробку можно было бы нарисовать и прямо в коде, но для этго пришлось бы обращаться к OpenGL в чистом виде, чего бы не хотелось для примера. В итоге для неба у меня получилось 6 DMD моделей и 6 текстур, ровно столько сторон у куба <img src="images/smiles/smile.gif" width=16 height=16 border=0>. В коде появляется 2 процедуры DrawSkyBox и LoadSkyBox, думаю их содержание не вызовет никаких вопросов, одна - просто загружает модели и текстуры для неба, а другая - рисует модели и устанавливает им текстуры. Вот некоторы комментарии к этому коду, а именно я поясню значение строки
<br>
TextureParametrs(left[1],TEXTURE_CLAMP);
<br>
которая вызывается для каждой из шести сторон скайбокса. Эта процедура задает параметры текстуре, они могут быть TEXTURE_REPEAT и TEXTURE_CLAMP. По умолчанию всем текстурам задается первое значение. Смысл этого в том что текстурные координаты по X и Y могут менятся от 0 до 1 и если текстуре установлен первый параметр то X и Y текстурные координаты могут менятся в обе стороны до бесконечности, при выходе за пределы текстуры она просто будет повторятся, во втором случае текстура будет приклеиваться четко к своим координатам. По моему не понятно описал :) но не важно важно что это надо для текстур скайбокса иначе будут артефакты на гранях т.к. существует небольшая погрешность текстурных координат.
<br>
Кстати, перед отрисовкой неба нужно вставить строчку:
<br>
ZBuffer(false);
<br>
А после соответственно:
<br>
ZBuffer(true);
<br>
Эта процедура отключает/включает ZBuffer. Что такое ZBuffer можно узнать в интернете, я просто скажу что если этого не сделать то руки с оружием будут "въезжать" в стенки уровня, а skybox будет визуально меньше всего уровня. А вот перед отрисовкой оружия ZBuffer надо просто очистить процедурой ClearZBuffer. Опять объяснил не понятно просто для этого достаточно элементарных знаний 3D и если их нет, то объяснить это крайне сложно, но опять же в принципе это и не к чему пока знать.
<br>
Ну в общем фиг с ним всем, теперь у нас уже рисуется небо и рука с пистолетом и это курто. Двигаемся дальше, введем 4 переменные:
<br>
CamA_X : single = 0;
<br>
CamA_Y : single = 0;
<br>
Pos : Tvertex;
<br>
OldMouse : TPoint;
<br>
Первые 2 это угол головы по оси X (т.е. когда вертим башкой вверх-вниз) и по Y, это когда смотрим вправо - влево. Pos - описывает положение игрока в мире (трехмерная координата). OldMouse - будет хранить координаты мышки, зачем она понадобится станет понятно ниже.
<br>
Итак, общая идея 3D мира заключается в том, что игрок(камера) - центр вселенной и все остальные объекты перемещаются относительно него. И перед отрисовкой уровня с врагами и т.д. нужно глобально перенести все это в позицию игрока и повернуть на углы (в нашем случае углы головы). Если написать кусок кода, то выглядеть это будет примерно так:
<br>
BeginObk3D;
<br>
рисуем skybox
<br>
EndObj3D;
<br>
BeginObj3D;
<br>
Смещаем весь мир в позицию игрока
<br>
Position3D(..);
<br>
AngleX(..);
<br>
AngleY(..);
<br>
AngleZ(..);
<br>
BeginObk3D;
<br>
Рисуем уровень, врагов и т.д.
<br>
EndObj3D;
<br>
EndObj3D;
<br>
BeginObj3D;
<br>
рисуем оружие
<br>
EndObj3D;
<br>
В результате получается, что изменения координат мира не влияет на оружие и небо, для неба надо лишь учитывать углы CamA_X и CamA_Y и поворачивать его на эти углы.
<br>
Ну так теперь нужно привязать перемещение мышки к этим самым углам. Делается это парой строк кода на процессе:
<br>
CamA_Y:=CamA_Y-(GetMousePos.X-OldMouse.X)/2;
<br>
CamA_X:=CamA_X-(GetMousePos.Y-OldMouse.Y)/2;
<br>
OldMouse:=GetMousePos;
<br>
Тут просто смотрим смещение мышки, делим на некий коэффициент (чуствительность) и вычитаем его из углов. Когда мышка достигает границ экрана ее нужно переносить на противоположную границу. Вот пример что происходит, когда мышка выезжает за правую границу экрана.
<br>
if GetMousePos.X=GetScreenResX-1 then
<br>
begin
<br>
OldMouse.X:=-1;
<br>
SetCursorPos(0,GetMousePos.Y);
<br>
end;
<br>
Как видим мышка просто перебрасывается по X-у. Аналогично делается и для остальных 3-х случаев. Это будет отлично работать если игра работает в полноэкранном режиме и не будет работать для оконного режима, я несколько усложнил этот код что бы он корректно работал и при оконном режиме, посмотреть его можно скачав пример к статье.
<br>
Вот теперь открываем 3DSMax и клепаем уровень по которому будет бегать игрок. При создании уровня стоит помнить о том, что столкновения с ним движок умеет расчитывать коробками (параллелипипедами точнее) т.е. вокруг каждого объекта описывается параллелипипед по этому если например землю сделать не плоскостю, а сложной геометрией то игрок в ней просто застрянет. Движок позволяет расчитать точные столкновения с геометрией (об этом я поговорю в следующей статье), но я не буду этого делать что бы не захламлять пример, по этому при проектировании уровня буду избегать подобных ситуаций. Так же в материалах моделей я сразу буду указывать текстуру bumpaи спекуляра, скрипт будет экспортировать их автоматически. При создание уровня я прибегнул к хитрости и создал два Box'а, один назвал - Player, а другой - Light. Мне это надо что бы узнать начальное положение игрока в уровне и позицию источника света а в самой игре я не буду их рисовать. Еще есть небольшая хитрость что бы просто и красиво делать деревья и прочую растительность. Делается текстура зелени с альфаканалом TGA например, дерево или кустарник лепится как набор пересекающихся плоскостей с текстурой зелени, а в свойствах материала этой зелени в максе ставится Opacity – 98, например. В движке есть такая недокументированная фича, что если прозрачность объекта сцены не сильно отличается от 100, то вместо блендинга будет использоваться альфа тест, т.е. крона дерева станет прозрачной без каких либо проблем пре перекрытии и сортировки при использовании блендинга. Ну вдаваться в тонкости 3ds не цель этой статьи, по этому я прилогаю к примеру статья max файл с уровнем, так что сами сможете посмотреть что там да как. Вот уровень создан и сохранен в папке "Data" там же есть 2 папки "tex" и "meshs", перейдем к его загрузке. Сразу скажу, моделлер из меня наихреновейший, по этому не пугайтесь убогости сцены ?.
<br>
А загружать сцену я буду так:
<br>
TextureMipMapping(true);
<br>
level:=LoadScene('Data\level.dsc','Data\meshs','Data\tex');
<br>
TextureMipMapping(false);
<br>
Вообщем все логично  я думаю и в особых комментариях не нуждается. Скажу лишь, что процедура TextureMipMapping включает и выключает генерацию mip уровней для загружаемых текстур. Это совершенно не обязательно но с ними смотрится получше )
<br>
Сейчас надо будет найти в сцене 2 коробки одна из которых описывает позицию игрока, а вторая – источник света. Узнать их положение в пространстве и скрыть что бы они не отрисовывались. Код будет выглядеть так (для света – аналогично):
<br>
Pos:=SceneGetObj(level,GetSceneObjectIdent(level,'player')).Pos;
<br>
SceneSetObjActive(level,GetSceneObjectIdent(level,'player'),false);
<br>
Первой строчкой мы обращаемся к объекту в загруженной сцене по имени «Player» и приравниваем позицию игрока на карте к позиции этого объекта, а второй строкой указываем объекту, что он не активен т.е. он не будет ни отрисовываться ни участвовать в обсчете столкновений со сценой. Ф-я SceneGetObj возвращает структуру с полными свойствами объекта, их можно поменять и установить объекту новые свойства процедурой SceneSetObj, весьма удобно не так ли ? Ну вот, теперь отрисуем нашу сцену и напишем вот такую процедуру:
<br>
procedure DrawLevel;
<br>
begin
<br>
  RotateX(CamA_X+90);
<br>
  RotateZ(CamA_Y);
<br>
  Position3D(-Pos.X,-Pos.Y,-Pos.Z);
<br>
  CalculateFrustum;
<br>
  DrawScene(level);
<br>
end;
<br>
Как видим, все опять очень просто, пояснить пожалуй стоит лишь процедуру CalculateFrustum, она рассчитывает зону видимости после глобальных изменений мира и при вызове процедуры DrawScene будут отрисовываться не все объекты, а только те, которые попадают в зону видимости. Проверять отдельные модели на попадание в зону видимости (фрустум) можно и самому например ф-ей IsBoxInFrustum. Кстати, что бы увидить всю сцену разом нужно до старта движка т.е. до вызова StartEngine; установить блюжнюю и дальнюю плоскости отсечении за которыми рисоваться ничего не будет, делается это вызовом процедуры вот так:
<br>
SetCutingPlanes(0.05,1000);
<br>
Теперь осталось рассчитать перемещение и столкновение по уровню. Я поясню это на примере обработки клавиши «W». Сперва я введу две переменные одна описывает размеры коробки столкновения вокруг игрока, это будет обычная трехмерная точка Vertex, значение X которой опишет ширину, Y – высоту и Z – глубину коробки. И переменную в которой будет хранится предыдущая позиция игрока на уровне вот так:
<br>
v, old : Tvertex;
<br>
А теперь код обработки клавиши «W»:
<br>
if IsKeyPressed(Key_W) or IsKeyPressed(Key_Down) then
<br>
 begin
<br>
 old:=pos;
<br>
 pos.X:=pos.X+2*cos(degtorad(CamA_Y + 90));
<br>
 if CollideBoxWithScene(level,pos,v) then Pos.X:=old.X;
<br>
 pos.Y:=pos.Y+2*sin(degtorad(CamA_Y + 90));
<br>
 if CollideBoxWithScene(level,pos,v) then Pos.Y:=old.Y;
<br>
 end;
<br> 
Идея обработки столкновения заключается в том, что сначало мы запоминаем предыдущее положение игрока, затем пытаемся сместить его по X и Y, если фиксируется столкновение, то возвращаем предыдущее значение. Значение ф-и CollideBoxWithScene я думаю объяснять не стоит. Эта функция рассчитывает достаточно грубые но быстрые столкновения, что бы рассчитать точные столкновения можно получить идентификатор объекта в сцене с последним из которых произошло столкновение, это можно сделать функцией SceneGetLastCollideObjectIndex, если столкновений не было то возвращается -1. Далее можно обратиться к объекту в сцене, а затем к мешу и получить его по треугольникам ну и как следствие рассчитать точные столкновение, но это уже ложится на программиста, может в следующей статье я покажу как это делать, пока лишь базовые вещи. Итак, вернемся к нашему коду, если написать аналогичный код для всех 4 кнопок, то можно будет перемещаться по карте как в FPS играх с расчетом столкновений. Еще теперь нам придется очищать ZBuffer перед отрисовкой оружия, процедурой ClearZBuffer; (об этом я уже писал чуть выше). Ну и финальный штрих это то, что мой импровизированный кустик на сцене не прозрачен это по тому что я вместо тга с альфаканалом использовал обычный JPEG, а при загрузке сцены движок увы не понял что текстуру нужна загрузить с прозрачностью, по этому мне придется перезагрузить ее вручную, выглядеть это будет вот так, пишем на процедуре загрузки:
<br>
m:=SceneGetObj(level,GetSceneObjectIdent(level,'Plane03'));
<br>
FreeTexture(m.Texture);
<br>
SetDefaultJPGTransparentColorTolerance(60);
<br>
m.Texture:=LoadTextureFromFile('Data\tex\grass.jpg',TEXDETAIL_BEST,$FFFFFF);
<br>
SceneSetObj(level,GetSceneObjectIdent(level,'Plane03'),m);
<br>
По стечению обстоятельств мой кустик называется в уровне «Plane03», просто забыл дать ему другое название ? 
<br>
А потом я подумал, что так плохо и переделал это таким образом что в цикле проверяется если на объект натянута текстура “grass.jpg”, то она ему заменяется на новую. Выглядит это вот так:
<br>
for i := 0 to SceneObjCount(level)-1 do
<br>
begin
<br>
m:=SceneGetObj(level,i);
<br>
if ModelMaterial(m.Mesh).TexFileName='grass.jpg' then
<br>
begin
<br>
  FreeTexture(m.Texture);
<br>
  m.Texture:=tex;
<br>
  SceneSetObj(level,i,m);
<br>
  end;
<br>  
end;
<br>
tex тут это уже правильно загруженная, как написано выше grass.jpg.
<br>
Тут мы запрашиваем структуру объекта сцены, освобождаем его текующую текстуру, а затем загружаем ее снова но уже с выставленным цветом прозрачности. Процедура предшествующая загрузке текстуры устанавливает 60% допуск на цвет прозрачности для текстур это нужно из-за того, что текстура зелени это JPG и если генерировать прозрачность просто по ключевому цвету без допуска то ничего хорошего не будет из-за артифактов при JPG кодировании изображений.
<br>
Блеск & Лоск
<br>
У нас уже есть какое-то подобие трехмерной игры, следующим шагом мы будем превращать нашу графику в конфетку, я не зря сразу заготовил и натягивал на объекты карты нормалей и спекуляр, сейчас с их помощью мы дотянем графику до уровн 21 века
<br>
Я подробнее остановлюсь на этом в следующей статье, сейчас я просто активирую Bump mapping для уровня, аналогично как это было в примере с движком. Можно разобраться по коду сразу, комментарии касательно nex-gen эффектов будут в следующий раз.
<br>
В следующей статье мы рассмотрим: динамические тени, точный обсчет столкновений и добавим выстрелы и врагов.
<br><br><b><a href="files/tutorial8.rar" target="_blank">Скачать пример из статьи [2.8 Mb] </a></b></p>



<br>
<center><img src="images/stop.gif" width=60 height=57 border=0></center><br>	
</td><tr>                      
<td colspan=2 align=right><img src="images/ugol.gif" width=45 height=49 border=0></td></tr>
</table>
</td></tr>
</table></td>
<td height=100% width=50 background="images/cornerr.gif">&nbsp;</td>
<? include("copy.txt");?>
<td height=1 width=50 background="images/cornerr.gif">&nbsp;</td></tr>
</tr></table>
</BODY>
</HTML>
